For our model, we made a relatively simple interface guaranteeing basic functionality (rendering, combining, adding/editing notes), 
in addition to getters. 
The interface is generic over the note type. This allows for a more broad model, with a number of possible implementations. 
We then made a basic implementation using an INote interface we created. The model used a TreeMap mapping beats to PitchCollections, which
then mapped to pitches with lists of the Notes at that pitch at that time. 
It added the pieces by putting them in the calling the add method on the PitchCollection at the correct beat, 
then adding to the correct Pitch from there.
For combining simultaneously, the other model is cast as a BasicMusicEditor model (from within the class), 
and then the notes from its list are added.
For combining consecutively, the notes to be added are moved over by the current length of the piece.
We implemented a ViewModel as a wrapper for our original class, with a BasicMusicEditor field and restricted functionality (inability to 
add/remove/edit notes).
From there, the midi, console, and gui implementations use the existed functionality to reder the piece respectively.


Controller specifications:


- To add a note, first press the key for the field you want to set (p for pitch, s for start beat, d for duration, 
v for volume, c for channel) and then press the key for the number you want to set it to (multiple consecutively 
if it is multiple digits). Repeat this process for all fields, the press a or right mouse click to add.
Ex: p 6 0 s 1 d 2 c 1 v 5 *left click* adds a half note for middle C at beat 1
- To remove, go through the same process except press r or left click at the end.
- To jump to beginning or end, press the home or end key, respectively.
- To pause or play, press the spacebar.
- To scroll, use the arrow keys
